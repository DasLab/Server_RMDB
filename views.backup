from django.http import Http404, HttpResponseRedirect
from django.template import RequestContext
from django.contrib.auth.decorators import login_required
from django.contrib.auth import authenticate, login, logout
from django.shortcuts import render_to_response
from models import *
from datahandlers import RDATFile
import matplotlib
matplotlib.use('Agg')
from pylab import *
#from mlabwrap import mlab
from settings import *
from django import forms
import os
import numpy

def save_annotations(dictionary, section, cl):
    count = 0
    for d in dictionary:
	a = cl()
	a.name = d.strip()
	if d.strip() == 'mutation':
	    count += 1
	a.value = dictionary[d]
	a.section = section
	a.save()
    return count

def get_arrays(datas):
    values = []
    traces = []
    xsels = []
    for d in datas:
	values.append(d.values)
	traces.append(d.trace)
	xsels.append(d.xsel)
    return array(values), array(traces), array(xsels)

def index(request):
    nentries = RMDBEntry.objects.all().count()
    nRNAs = ConstructSection.objects.values('name').distinct().count()
    nconstructs = 0
    ndatapoints = 0
    for e in RMDBEntry.objects.all():
	ndatapoints += e.datacount
	nconstructs += e.constructcount
    return render_to_response('index.html', {'nentries':nentries, 'nRNAs':nRNAs, 'nconstructs':nconstructs,\
                              'ndatapoints':ndatapoints}, context_instance=RequestContext(request))

def contact(request):
    return render_to_response('contact.html', {})

def tools(request):
    return render_to_response('tools.html', {})

def specs(request):
    return render_to_response('specs.html', {})

def search(request):
    sstring = request.GET['searchtext'].strip()
    # Let's guess the search text type
    if sstring[:2] == 'rm':
        try:
	    entry = RMDBEntry.objects.get(pk=sstring.replace('rm',''))
	    return HttpResponseRedirect('/repository/detail/%s'%entry.id)
	except RMDBEntry.DoesNotExist:
	    pass
    entries = RMDBEntry.objects.filter(constructsection__name__contains=sstring)
    for e in entries:
	e.constructs = ConstructSection.objects.filter(entry=e)
	e.short_description = e.description[:30]+'...'
    return render_to_response('results.html', {'entries':entries, 'sstring':sstring}, context_instance=RequestContext(request))



def detail(request, entry_id):
    data_annotations_exist = False
    try:
        entry = RMDBEntry.objects.get(pk=entry_id)
	entry.annotations = EntryAnnotation.objects.filter(section=entry)
	constructs = ConstructSection.objects.filter(entry=entry)
	for c in constructs:
	    c.datas = DataSection.objects.filter(construct_section=c)
	    c.annotations = ConstructAnnotation.objects.filter(section=c)
	    for d in c.datas:
		d.annotations = DataAnnotation.objects.filter(section=d)
		if d.annotations:
		    data_annotations_exist = True
    except RMDBEntry.DoesNotExist:
        raise Http404
    return render_to_response('detail.html', {'entry':entry, 'constructs':constructs, 'publication':entry.publication,\
                              'data_annotations_exist':data_annotations_exist}, context_instance=RequestContext(request))

class BrowseResults:
    pass

def browse(request):
    names_d = ConstructSection.objects.values('name').distinct()
    constructs = [BrowseResults() for i in range(len(names_d))] 
    for i, c in enumerate(names_d):
	constructs[i].name = c['name']
        constructs[i].entries = RMDBEntry.objects.filter(constructsection__name=c['name'])
    return render_to_response('browse.html', {'constructs':constructs}, context_instance=RequestContext(request))

@login_required
def upload(request):
    if request.method == 'POST':
	form = UploadForm(request.POST, request.FILES)
	rdatfile = RDATFile()
	uploadfile = request.FILES['file']
        rf = open('/tmp/%s'%uploadfile.name, 'w')
	rf.write(uploadfile.read())
        rf.close()
        rf = open('/tmp/%s'%uploadfile.name)
	rdatfile.load(rf)
	publication = Publication()
	publication.title = request.POST['publication']
	publication.authors = request.POST['authors']
	publication.save()
	datacount = 0
	constructcount = 0
	entry = RMDBEntry()
	entry.version = rdatfile.version
	entry.comments = rdatfile.comments
	entry.publication = publication
	entry.authors = request.POST['authors']
	entry.description = request.POST['description']
	entry.type = request.POST['type']
	entry.datacount = 0
	entry.constructcount = 0
	entry.revision_status = 'PUB'
	entry.save()
        save_annotations(rdatfile.annotations, entry, EntryAnnotation)
	for k in rdatfile.constructs:
	    constructcount += 1
            c = rdatfile.constructs[k]
	    construct = ConstructSection()
	    construct.entry = entry
	    construct.name = c.name
	    construct.sequence = c.sequence
	    construct.offset = c.offset
	    construct.structure = c.structure
	    construct.seqpos = c.seqpos
	    construct.xsel = ','.join([str(x) for x in c.xsel])
	    construct.save()
   	    save_annotations(c.annotations, construct, ConstructAnnotation)
	    for d in c.data:
		data = DataSection()
		data.xsel = ','.join([str(x) for x in d.xsel])
		data.values = ','.join([str(x) for x in d.values])
		data.errors = ','.join([str(x) for x in d.errors])
		datacount += len(d.values)
		data.trace = ','.join([str(x) for x in d.trace])
		data.seqpos = ','.join([str(x) for x in d.seqpos])
		data.construct_section = construct
		data.save()
		constructcount += save_annotations(d.annotations, data, DataAnnotation)
	    entry.datacount = datacount
	    entry.constructcount = constructcount
	    entry.save()
	    generate_images(construct, c, engine='matplotlib')
        return HttpResponseRedirect('/repository/detail/%s'%entry.id)
    else:
	form = UploadForm()
    return render_to_response('upload.html', {'form':form}, context_instance=RequestContext(request))

def generate_images(construct_model, construct_section, engine='matplotlib'):
    dir = CONSTRUCT_IMG_DIR+'%s/'%construct_model.id
    if not os.path.exists(dir):
	os.mkdir(dir)
    values_array, trace_array, xsel_array = get_arrays(construct_section.data)
    values_dims = shape(values_array)
    trace_dims = shape(trace_array)
    values_mean = values_array.mean(axis=0)
    values_std = values_array.std(axis=0)
    if engine == 'matplotlib':
	figure(2, figsize=((1+values_dims[1]%4)*8,(1+values_dims[0]%4)*8))
	imshow(trace_array, cmap=get_cmap('Greys'), vmin=0, vmax=trace_array.mean(), aspect='auto', interpolation='nearest')
	savefig(dir+'/trace.png')
	figure(2, figsize=((1+values_dims[1]%4)*8,(1+values_dims[0]%4)*8))
	clf()
	imshow(values_array, cmap=get_cmap('Greys'), vmin=0, vmax=values_array.mean(), aspect='auto', interpolation='nearest')
	savefig(dir+'/values.png')
	figure(3)
	clf()
	hist(values_array.reshape(size(values_array)), 50)
	savefig(dir+'/values_hist.png')
	figure(3)
	clf()
	hist(trace_array.reshape(size(trace_array)), 50)
	savefig(dir+'/trace_hist.png')
	figure(1)
	clf()
	matshow(corrcoef(values_array.T)**10)
	savefig(dir+'/corrcoef.png')
	figure(1)
	clf()
	bar(range(values_dims[1]), values_mean, yerr=values_std)
	seq = ''
	for i in construct_section.seqpos:
	    seq += construct_section.sequence[i - construct_section.offset]
	labels = ['%s%s' % (s,construct_section.seqpos[i]) for i, s in enumerate(seq)]
	xticks(range(len(labels)), labels, rotation=90)
	savefig(dir+'/barplot.png')
    elif engine == 'matlab':
    	h = mlab.figure(1)
	mlab.clf()
	mlab.colormap( 1 - mlab.gray(100));
        mlab.image( 100 * trace_array/trace_array.mean().mean()  )
	mlab.saveas(h, dir+'/trace.png')
    	h = mlab.figure(2)
	mlab.clf()
	mlab.colormap( 1 - mlab.gray(100));
        mlab.image( 100 * values_array/values_array.mean().mean()  )
	mlab.saveas(h, dir+'/values.png')
	figure(3)
	clf()
	hist(values_array.reshape(size(values_array)), 50)
	savefig(dir+'/values_hist.png')
	figure(3)
	clf()
	hist(trace_array.reshape(size(trace_array)), 50)
	savefig(dir+'/trace_hist.png')
	figure(1)
	clf()
	matshow(corrcoef(values_array.T)**10)
	savefig(dir+'/corrcoef.png')
	figure(1)
	clf()
	bar(range(values_dims[1]), values_mean, yerr=values_std)
	seq = ''
	for i in construct_section.seqpos:
	    seq += construct_section.sequence[i - construct_section.offset]
	labels = ['%s%s' % (s,construct_section.seqpos[i]) for i, s in enumerate(seq)]
	xticks(range(len(labels)), labels, rotation=90)
	savefig(dir+'/barplot.png')
    else:
	raise Exception('Uknown plotting engine '+engine)


def user_login(request):
    if 'next' in request.GET: 
	next = request.GET['next']
    else:
	next = '/repository/'
    if request.method == 'POST':
        form = LoginForm(request.POST)
	username = request.POST['username']
	password = request.POST['password']
	user = authenticate(username=username, password=password)
	if user is not None:
	    if user.is_active:
		login(request, user)
	        return HttpResponseRedirect(next)
	    else:
	        return render_to_response('login.html', {'form':form, 'error_msg':'This account has been disabled', 'next':next},\
		                          context_instance=RequestContext(request))
	else:
	    return render_to_response('login.html', {'form':form, 'error_msg':'Username and/or password incorrect', 'next':next},\
	                              context_instance=RequestContext(request)) 
    else:
        form = LoginForm()
        return render_to_response('login.html', {'form':form, 'error_msg':'', 'next':next}, context_instance=RequestContext(request))

def user_logout(request):
    logout(request)
    return HttpResponseRedirect('/repository/')
